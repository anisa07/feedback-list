import {
    createAsyncThunk,
    createSlice,
    PayloadAction,
} from '@reduxjs/toolkit';
import type { RootState } from '../store/store';
import {CategoryType, FeedbackType, RoadmapType} from "../types/FeedbackType";
import {getFeedbackData, getTypes} from "../services/feedbackService";

export type FeedbackState = {
    feedbackList: FeedbackType[];
    roadmap: RoadmapType[];
    types: CategoryType[];
};

const initialState: FeedbackState = {
    feedbackList: [],
    roadmap: [],
    types: []
};

export const getFeedbackAllData = createAsyncThunk('feedback/feedbackAllData', async () => {
    const types = await getTypes()
    const feedbackData = await getFeedbackData();
    return {
        types,
        roadmap: feedbackData.roadmap,
        feedbackList: feedbackData.feedbackList,
    }
});

export const feedbackSlice = createSlice({
    name: 'feedback',
    initialState,
    reducers: {
        updateFeedbackList: (state, action: PayloadAction<FeedbackType[]>) => {
            state.feedbackList = action.payload;
        },
        updateRoadmap:  (state, action: PayloadAction<RoadmapType[]>) => {
            state.roadmap = action.payload;
        },
    },
    extraReducers: builder => {
        builder
            .addCase(getFeedbackAllData.pending, state => {})
            .addCase(getFeedbackAllData.fulfilled, (state, { payload }) => {
                state.feedbackList = payload.feedbackList;
                state.roadmap = payload.roadmap;
                state.types = payload.types;
            })
            .addCase(getFeedbackAllData.rejected, state => {});
    },
});

export const {
    updateFeedbackList,
    updateRoadmap
} = feedbackSlice.actions;

export const selectFeedbackList = (state: RootState) => state.feedback.feedbackList
export const selectRoadmap = (state: RootState) => state.feedback.roadmap;
export const selectTypes = (state: RootState) => state.feedback.types;

export default feedbackSlice.reducer;

// import {
//     createAsyncThunk,
//     createSlice,
// } from '@reduxjs/toolkit';
// import axios from 'axios';
// import type { RootState } from '../../app/store';
//
// // here we are typing the types for the state
// export type KanyeState = {
//     data: { quote: string };
//     pending: boolean;
//     error: boolean;
// };
//
// const initialState: KanyeState = {
//     data: { quote: 'click that button' },
//     pending: false,
//     error: false,
// };
//
// // This action is what we will call using the dispatch in order to trigger the API call.
// export const getKanyeQuote = createAsyncThunk('kanye/kanyeQuote', async () => {
//     const response = await axios.get('https://api.kanye.rest/');
//
//     return response.data;
// });
//
// export const kanyeSlice = createSlice({
//     name: 'kanye',
//     initialState,
//     reducers: {
// // leave this empty here
//     },
// // The `extraReducers` field lets the slice handle actions defined elsewhere, including actions generated by createAsyncThunk or in other slices.
// // Since this is an API call we have 3 possible outcomes: pending, fulfilled and rejected. We have made allocations for all 3 outcomes.
// // Doing this is good practice as we can tap into the status of the API call and give our users an idea of what's happening in the background.
//     extraReducers: builder => {
//         builder
//             .addCase(getKanyeQuote.pending, state => {
//                 state.pending = true;
//             })
//             .addCase(getKanyeQuote.fulfilled, (state, { payload }) => {
// // When the API call is successful and we get some data,the data becomes the `fulfilled` action payload
//                 state.pending = false;
//                 state.data = payload;
//             })
//             .addCase(getKanyeQuote.rejected, state => {
//                 state.pending = false;
//                 state.error = true;
//             });
//     },
// });
//
// export const selectKanye = (state: RootState) => state.kanyeQuote;
//
// export default kanyeSlice.reducer;
